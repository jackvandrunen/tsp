[{"fullname": "tsp", "modulename": "tsp", "qualname": "", "type": "module", "doc": "<p>A library for cognitive science research on the traveling salesperson problem (TSP).</p>\n\n<p>The library is divided up into three modules, each with a number of submodules. The <code>tsp.core</code>\nmodule implements general purpose tools for writing TSP experiments: object-oriented containers for\nTSPs of 2 (or more!) dimensions, basic solvers implementing random tour, optimal tour (via\nConcorde), and pyramid (hierarchical clustering) tour, serialization for TSPs and tours, and\nvisualization of TSPs and tours.</p>\n\n<p>The <code>tsp.extra</code> module implements extensions for modern TSP research, mainly research on two\ndifferent kinds of \"not-Euclidean\" TSPs, as well as the supporting code for serialization and\nvisualization.</p>\n\n<p>The <code>tsp.experiment</code> module implements tools for running experiments, including helper functions\nfor saving whole sets of problems and tours and calculating statistics, as well as a user interface\nfor collecting human participant tours of problem sets.</p>\n\n<p>This code has been used to generate results for a couple of abstracts so far, and implements\nsome experiments described in others. It serves as a companion to the book <em>Problem Solving:\nCognitive Mechanisms and Formal Models</em>. See the <a href=\"https://github.com/jackvandrunen/tsp\">README</a> for\ncitations.</p>\n"}, {"fullname": "tsp.core", "modulename": "tsp.core", "qualname": "", "type": "module", "doc": "<p>General purpose tools for writing TSP experiments.</p>\n\n<p>This module has five component submodules. The <code>tsp.core.tsp</code> submodule has object-oriented\ncontainers for both 2-dimensional and n-dimensional TSPs, including procedures for randomly\ngenerating 2-dimensional TSPs.</p>\n\n<p>The <code>tsp.core.solvers</code> submodule implements random, optimal, and human-approximate solvers. The\noptimal solver uses the <a href=\"https://www.math.uwaterloo.ca/tsp/concorde.html\">Concorde</a> backend. The\nhuman-approximate solver uses a hierarchical clustering (\"pyramid\") algorithm implemented in the\n<code>tsp.core.pyramid</code> submodule.</p>\n\n<p>The <code>tsp.core.save</code> submodule implements procedures for serializing TSP objects and tours.</p>\n\n<p>The <code>tsp.core.viz</code> submodule implements procedures for visualizing 2D TSPs and tours using either a\nPython Imaging Library (PIL) backend or a MatPlotLib backend. Using OpenCV, it can also generate\nmovies visualizing 3D TSPs using simulated 3D motion.</p>\n"}, {"fullname": "tsp.core.pyramid", "modulename": "tsp.core.pyramid", "qualname": "", "type": "module", "doc": "<p>Implements a hierarchical clustering (\"pyramid\") algorithm similar to those used in the\nliterature to approximate human solutions to the TSP.</p>\n\n<p>Most all of this is not of interest to the casual user of the library, as the important bits are\nwrapped by <code>tsp.core.solvers.PyramidSolver</code>. Following is a rundown of the pyramid algorithm.</p>\n\n<p>First, we construct a minimum spanning tree (MST) of the cities in the problem using\nBor\u016fvka's algorithm. During the MST-construction stage, the algorithm constructs a dendrogram using\na disjoint-set data structure which stores the Bor\u016fvka's clusters as trees, building them upwards\nas they are joined together by adding edges to the MST until one dendrogram results.</p>\n\n<p>This dendrogram can be conceptualized as a pyramid. The top level of a pyramid can be derived by\nbreaking up the dendrogram into N subtrees by slicing off the N branches nearest to the top,\ncollecting all of the cities in each of the trees and finding their centers of gravity. This\nproduces a cluster of N centroids in the space of the original problem. This can be done at any\nlevel of the tree, so a subtree can in turn be broken up into its component clusters.</p>\n\n<p>At the top level of the pyramid, the shortest tour can be found precisely in constant time because\nthere are now a constant number of cities (N) which compose the problem. Once this tour is found,\neach of the N centroids which make up the top level are broken down into the N centroids beneath\nthem, and a shortest path through these centroids is constructed and added to the final tour. This\nshortest path takes into account the centroid of the \"next\" cluster to be visited, as well as the\nlast city in the shortest path through the \"previous\" cluster. This process of iterative refinement\nof the tour is repeated until all clusters have been broken up and only the cities of the original\nproblem remain.</p>\n\n<p>See the documentation of <code>pyramid_debug</code> for another characterization of the operation of this\npyramid model.</p>\n"}, {"fullname": "tsp.core.pyramid.DSNode", "modulename": "tsp.core.pyramid", "qualname": "DSNode", "type": "class", "doc": "<p>Implements a disjoint-set dendrogram.</p>\n"}, {"fullname": "tsp.core.pyramid.DSNode.__init__", "modulename": "tsp.core.pyramid", "qualname": "DSNode.__init__", "type": "function", "doc": "<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>value (Any):</strong>  value to store at this node (can be literally anything)</li>\n<li><strong>children (List[DSNode], optional):</strong>  Nodes immediately below this one. Defaults to [].</li>\n<li><strong>height (int, optional):</strong>  Numerical value expressing the depth of the tree below it. Defaults to 0.</li>\n</ul>\n", "parameters": ["self", "value", "children", "height"], "funcdef": "def"}, {"fullname": "tsp.core.pyramid.DSNode.find", "modulename": "tsp.core.pyramid", "qualname": "DSNode.find", "type": "function", "doc": "<p>Recursively finds the root of the tree.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>DSNode: root</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "tsp.core.pyramid.DSNode.split", "modulename": "tsp.core.pyramid", "qualname": "DSNode.split", "type": "function", "doc": "<p>Returns the depth + 1 clusters produced by descending the dendrogram.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>depth (int, optional):</strong>  how many levels down the dendrogram to split. Defaults to 1.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>List[DSNode]: depth + 1 roots of the subtrees</p>\n</blockquote>\n", "parameters": ["self", "depth"], "funcdef": "def"}, {"fullname": "tsp.core.pyramid.DSNode.values", "modulename": "tsp.core.pyramid", "qualname": "DSNode.values", "type": "function", "doc": "<p>List this node's value and all values below it.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>List[Any]: values</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "tsp.core.pyramid.DSTree", "modulename": "tsp.core.pyramid", "qualname": "DSTree", "type": "class", "doc": "<p>Container for building the disjoint-set dendrogram.</p>\n"}, {"fullname": "tsp.core.pyramid.DSTree.__init__", "modulename": "tsp.core.pyramid", "qualname": "DSTree.__init__", "type": "function", "doc": "<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>values (List[Any], optional):</strong>  Initial leaves to initialize. Defaults to None.</li>\n</ul>\n", "parameters": ["self", "values"], "funcdef": "def"}, {"fullname": "tsp.core.pyramid.DSTree.sets", "modulename": "tsp.core.pyramid", "qualname": "DSTree.sets", "type": "variable", "doc": "<p>Number of disjoint sets in the tree.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>int: number of sets</p>\n</blockquote>\n"}, {"fullname": "tsp.core.pyramid.DSTree.make_set", "modulename": "tsp.core.pyramid", "qualname": "DSTree.make_set", "type": "function", "doc": "<p>Initialize a new set/leaf of tree.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>value (Any):</strong>  value to store at node</li>\n</ul>\n", "parameters": ["self", "value"], "funcdef": "def"}, {"fullname": "tsp.core.pyramid.DSTree.find", "modulename": "tsp.core.pyramid", "qualname": "DSTree.find", "type": "function", "doc": "<p>Find root of tree containing node which stores value.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>value (Hashable):</strong>  value of node of interest</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>DSNode: root of tree</p>\n</blockquote>\n", "parameters": ["self", "value"], "funcdef": "def"}, {"fullname": "tsp.core.pyramid.DSTree.union", "modulename": "tsp.core.pyramid", "qualname": "DSTree.union", "type": "function", "doc": "<p>Create a union of set containing x and set containing y.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>x (Hashable):</strong>  value which picks out first set</li>\n<li><strong>y (Hashable):</strong>  value which picks out second set</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>DSNode: root of new tree which is the union of the sets (or not-new if they're both in the same set)</p>\n</blockquote>\n", "parameters": ["self", "x", "y"], "funcdef": "def"}, {"fullname": "tsp.core.pyramid.centroid", "modulename": "tsp.core.pyramid", "qualname": "centroid", "type": "function", "doc": "<p>Gets pre-computed centroid of node in tree.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>c (DSNode):</strong>  parent node of relevance</li>\n<li><strong>nodes (NDArray):</strong>  master list of coordinates of points</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>NDArray: centroid</p>\n</blockquote>\n", "parameters": ["c", "nodes"], "funcdef": "def"}, {"fullname": "tsp.core.pyramid.cluster_kruskal", "modulename": "tsp.core.pyramid", "qualname": "cluster_kruskal", "type": "function", "doc": "<p>Agglomerate nodes based on their MST, given coordinates in n-dimensions.\nUses Kruskal's algorithm, which runs in O(v^2 log v)</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>nodes (NDArray):</strong>  ndarray((v, n))</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Tuple[Set, DSNode]: (edges in MST, root of agglomerated tree)</p>\n</blockquote>\n", "parameters": ["nodes"], "funcdef": "def"}, {"fullname": "tsp.core.pyramid.cluster_boruvka", "modulename": "tsp.core.pyramid", "qualname": "cluster_boruvka", "type": "function", "doc": "<p>Agglomerate nodes based on their MST, given coordinates in n-dimensions.\nUses Boruvka's algorithm: which should produce a more \"balanced\" tree.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>nodes (NDArray):</strong>  ndarray((v, n))</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Tuple[Set, DSNode]: (edges in MST, root of agglomerated tree)</p>\n</blockquote>\n", "parameters": ["nodes"], "funcdef": "def"}, {"fullname": "tsp.core.pyramid.mst", "modulename": "tsp.core.pyramid", "qualname": "mst", "type": "function", "doc": "<p>Generate an MST (shorthand for <code>cluster_boruvka(nodes)[0]</code>).</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>nodes (NDArray):</strong>  ndarray((v, n))</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Set: edges in MST</p>\n</blockquote>\n", "parameters": ["nodes"], "funcdef": "def"}, {"fullname": "tsp.core.pyramid.cluster", "modulename": "tsp.core.pyramid", "qualname": "cluster", "type": "function", "doc": "<p>Agglomerate nodes into dendrogram (shorthand for <code>cluster_boruvka(nodes)[1]</code>).</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>nodes (NDArray):</strong>  ndarray((v, n))</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>DSNode: root of agglomerated tree</p>\n</blockquote>\n", "parameters": ["nodes"], "funcdef": "def"}, {"fullname": "tsp.core.pyramid.solve_level", "modulename": "tsp.core.pyramid", "qualname": "solve_level", "type": "function", "doc": "<p>Find shortest path/tour through a branch of the tree.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>nodes (NDArray):</strong>  master list of coordinates of points</li>\n<li><strong>c (DSNode):</strong>  parent node of branch</li>\n<li><strong>k (int):</strong>  cluster size</li>\n<li><strong>left (int, optional):</strong>  Left (starting) node, if computing a path. Defaults to None.</li>\n<li><strong>right (int, optional):</strong>  Right (ending) node, if computing a path. Defaults to None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>List[int]: shortest path/tour</p>\n</blockquote>\n", "parameters": ["nodes", "c", "k", "left", "right"], "funcdef": "def"}, {"fullname": "tsp.core.pyramid.pyramid_solve", "modulename": "tsp.core.pyramid", "qualname": "pyramid_solve", "type": "function", "doc": "<p>Find an approximately-optimal tour using heirarchical clustering algorithm.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>nodes (NDArray):</strong>  master list of coordinates of points</li>\n<li><strong>k (int, optional):</strong>  Cluster size. Defaults to 6.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>List[int]: tour</p>\n</blockquote>\n", "parameters": ["nodes", "k"], "funcdef": "def"}, {"fullname": "tsp.core.pyramid.pyramid_debug", "modulename": "tsp.core.pyramid", "qualname": "pyramid_debug", "type": "function", "doc": "<p>Starts by yielding the centroids at the top level of the pyramid, then the level below, and so on, in the following pattern:</p>\n\n<ol>\n<li>tour of centroids at top of pyramid: [a, b, c, d, e, f]</li>\n<li>[cluster below a, b, c, d, e, f]</li>\n<li>[cluster below a, cluster below b, c, d, e, f]</li>\n<li>...</li>\n<li>[cluster below a, cluster below b, ..., cluster below f]</li>\n<li>Repeating from 1 for the next level of the pyramid (which is the tour produced in 5).</li>\n</ol>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>nodes (NDArray):</strong>  master list of coordinates of points</li>\n<li><strong>k (int, optional):</strong>  Cluster size. Defaults to 6.</li>\n</ul>\n\n<h6 id=\"yields\">Yields</h6>\n\n<blockquote>\n  <p>Iterator[List[int]]: [description]</p>\n</blockquote>\n", "parameters": ["nodes", "k"], "funcdef": "def"}, {"fullname": "tsp.core.save", "modulename": "tsp.core.save", "qualname": "", "type": "module", "doc": "<p>Procedures for serializing TSP objects and tours.</p>\n\n<p>Prefer <code>save_problem</code> and <code>load_problem</code> over <code>save_ntsp</code>, etc. These are general-purpose\nprocedures which determine the type of the problem and the proper procedure for serialization.\nNote also that <code>tsp.extra.save.save_problem</code> and <code>tsp.extra.save.load_problem</code> work on a strict\n<em>superset</em> of the problem types handled by <code>save_problem</code> and <code>load_problem</code>, so can be dropped\nin for these seamlessly.</p>\n\n<p>Use <code>save_list</code> and <code>load_list</code> to serialize and unserialize tours. The conventional extension for\ntours is <code>.sol</code> (for \"solution\").</p>\n\n<p>See <code>tsp.experiment.batch</code> for procedures for serializing whole sets of problems and tours.</p>\n"}, {"fullname": "tsp.core.save.LoadError", "modulename": "tsp.core.save", "qualname": "LoadError", "type": "class", "doc": "<p>Exception for expected problems with loading files.</p>\n"}, {"fullname": "tsp.core.save.save_ntsp", "modulename": "tsp.core.save", "qualname": "save_ntsp", "type": "function", "doc": "<p>Serialize an N_TSP object.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>obj (N_TSP):</strong>  object</li>\n<li><strong>path (str):</strong>  path to save</li>\n</ul>\n", "parameters": ["obj", "path"], "funcdef": "def"}, {"fullname": "tsp.core.save.load_ntsp", "modulename": "tsp.core.save", "qualname": "load_ntsp", "type": "function", "doc": "<p>Unserialize an N_TSP object.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>path (str):</strong>  path to load</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>N_TSP: object</p>\n</blockquote>\n", "parameters": ["path"], "funcdef": "def"}, {"fullname": "tsp.core.save.save_tsp", "modulename": "tsp.core.save", "qualname": "save_tsp", "type": "function", "doc": "<p>Serialize a TSP object.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>obj (TSP):</strong>  object</li>\n<li><strong>path (str):</strong>  path to save</li>\n</ul>\n", "parameters": ["obj", "path"], "funcdef": "def"}, {"fullname": "tsp.core.save.load_tsp", "modulename": "tsp.core.save", "qualname": "load_tsp", "type": "function", "doc": "<p>Unserialize a TSP object.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>path (str):</strong>  path to load</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>TSP: object</p>\n</blockquote>\n", "parameters": ["path"], "funcdef": "def"}, {"fullname": "tsp.core.save.save_problem", "modulename": "tsp.core.save", "qualname": "save_problem", "type": "function", "doc": "<p>Serialize an object (should be descended from N_TSP).</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>obj (Any):</strong>  object</li>\n<li><strong>path (str):</strong>  path to save</li>\n</ul>\n", "parameters": ["obj", "path"], "funcdef": "def"}, {"fullname": "tsp.core.save.load_problem", "modulename": "tsp.core.save", "qualname": "load_problem", "type": "function", "doc": "<p>Unserialize an object (TSP or N_TSP).</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>path (str):</strong>  path to load</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>LoadError:</strong>  serialized object not TSP or N_TSP</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Any: object</p>\n</blockquote>\n", "parameters": ["path"], "funcdef": "def"}, {"fullname": "tsp.core.save.save_list", "modulename": "tsp.core.save", "qualname": "save_list", "type": "function", "doc": "<p>Generic save function for tours/sequences of various formats.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>obj (Iterable[Any]):</strong>  list</li>\n<li><strong>path (str):</strong>  path to save</li>\n</ul>\n", "parameters": ["obj", "path"], "funcdef": "def"}, {"fullname": "tsp.core.save.load_list", "modulename": "tsp.core.save", "qualname": "load_list", "type": "function", "doc": "<p>Generic load function for tours/sequences of various formats.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>path (str):</strong>  path to load</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>List[Any]: list</p>\n</blockquote>\n", "parameters": ["path"], "funcdef": "def"}, {"fullname": "tsp.core.solvers", "modulename": "tsp.core.solvers", "qualname": "", "type": "module", "doc": "<p>Implements random, optimal, and human-approximate solvers.</p>\n\n<p>Other solvers can be implemented by extending <code>Solver</code>, which functions as an abstract class. Due\nto a historical contingency in the depths of the past, the API is somewhat opaque, and it's\nquestionable whether we might have been better off if the solvers weren't object-oriented. The\nbasic idea is that the initializer sets up the solver, and then the <code>__call__</code> method is what does\nthe computation and returns the tour. So, <code>Solver.__init__</code> and <code>Solver.__call__</code> should be\noverridden by subclasses - while <code>Solver.solve</code> is a newer addition serving as syntactical sugar\nfor <code>Solver.__call__</code>.</p>\n\n<p>The random solver is exactly as advertised - returning a random permutation of the cities as a\nsolution.</p>\n\n<p>The optimal solver uses the <a href=\"https://www.math.uwaterloo.ca/tsp/concorde.html\">Concorde</a> backend.\nSadly, Concorde can be a difficult thing to get working on a machine, but it is the gold standard\nin cognitive science research on TSP. Once you have Concorde installed, it is much easier using\nthis library to find optimal tours than using Concorde directly.</p>\n\n<p>The human-approximate solver uses a hierarchical clustering (\"pyramid\") algorithm implemented in the\n<code>tsp.core.pyramid</code> submodule.</p>\n"}, {"fullname": "tsp.core.solvers.Solver", "modulename": "tsp.core.solvers", "qualname": "Solver", "type": "class", "doc": "<p>Abstract class for generic TSP solvers.</p>\n"}, {"fullname": "tsp.core.solvers.Solver.__init__", "modulename": "tsp.core.solvers", "qualname": "Solver.__init__", "type": "function", "doc": "<p>Set up the solver based on the given problem.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tsp (N_TSP):</strong>  problem to be solved.</li>\n</ul>\n", "parameters": ["self", "tsp"], "funcdef": "def"}, {"fullname": "tsp.core.solvers.Solver.solve", "modulename": "tsp.core.solvers", "qualname": "Solver.solve", "type": "function", "doc": "<p>Run the solver and produce a tour.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>NDArray: tour as indices of cities</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "tsp.core.solvers.RandomSolver", "modulename": "tsp.core.solvers", "qualname": "RandomSolver", "type": "class", "doc": "<p>A solver which produces a random tour.</p>\n"}, {"fullname": "tsp.core.solvers.RandomSolver.__init__", "modulename": "tsp.core.solvers", "qualname": "RandomSolver.__init__", "type": "function", "doc": "<p>Set up the solver based on the given problem.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tsp (N_TSP):</strong>  problem to be solved.</li>\n</ul>\n", "parameters": ["self", "tsp"], "funcdef": "def"}, {"fullname": "tsp.core.solvers.ConcordeSolver", "modulename": "tsp.core.solvers", "qualname": "ConcordeSolver", "type": "class", "doc": "<p>An optimal solver with the Concorde backend.</p>\n"}, {"fullname": "tsp.core.solvers.ConcordeSolver.__init__", "modulename": "tsp.core.solvers", "qualname": "ConcordeSolver.__init__", "type": "function", "doc": "<p>Set up the solver based on the given problem.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tsp (N_TSP):</strong>  problem to be solved.</li>\n</ul>\n", "parameters": ["self", "tsp"], "funcdef": "def"}, {"fullname": "tsp.core.solvers.PyramidSolver", "modulename": "tsp.core.solvers", "qualname": "PyramidSolver", "type": "class", "doc": "<p>A solver which implements a pyramid approximator.</p>\n"}, {"fullname": "tsp.core.solvers.PyramidSolver.__init__", "modulename": "tsp.core.solvers", "qualname": "PyramidSolver.__init__", "type": "function", "doc": "<p>Set up the solver based on the given problem.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tsp (N_TSP):</strong>  problem to be solved.</li>\n</ul>\n", "parameters": ["self", "tsp"], "funcdef": "def"}, {"fullname": "tsp.core.tsp", "modulename": "tsp.core.tsp", "qualname": "", "type": "module", "doc": "<p>Object-oriented containers for both 2-dimensional and n-dimensional TSPs, including procedures\nfor randomly generating 2-dimensional TSPs.</p>\n\n<p><code>N_TSP</code> is the superclass from which all TSPs here and in <code>tsp.extra</code> inherit. It can handle TSPs\nof arbitrary dimension, and implements all the methods needed for a Solver\n(tsp.core.solvers.Solver) to be able to generate a tour. The convention is that TSPs are stored as\ncollections of cities, with distance matrices made available as second-class citizens.</p>\n\n<p><code>TSP</code> extends <code>N_TSP</code>, enforcing 2-dimensional cities and storing width (<code>TSP.w</code>) and height\n(<code>TSP.h</code>) attributes. It also implements a constructor (class method) for generating problems with\nuniformly-randomly distributed cities (TSP).</p>\n\n<p>To copy a TSP, you can use the <code>from_cities</code> class method. Example usage:</p>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c1\"># generate a TSP from an N_TSP with 2-dimensional cities</span>\n<span class=\"c1\"># ... (N_TSP stored as `original_problem`)</span>\n<span class=\"n\">problem_2d</span> <span class=\"o\">=</span> <span class=\"n\">TSP</span><span class=\"o\">.</span><span class=\"n\">from_cities</span><span class=\"p\">(</span><span class=\"n\">original_problem</span><span class=\"o\">.</span><span class=\"n\">cities</span><span class=\"p\">,</span> <span class=\"n\">w</span><span class=\"o\">=</span><span class=\"mi\">500</span><span class=\"p\">,</span> <span class=\"n\">h</span><span class=\"o\">=</span><span class=\"mi\">500</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># convert back</span>\n<span class=\"n\">original_problem</span> <span class=\"o\">=</span> <span class=\"n\">N_TSP</span><span class=\"o\">.</span><span class=\"n\">from_cities</span><span class=\"p\">(</span><span class=\"n\">problem_2d</span><span class=\"o\">.</span><span class=\"n\">cities</span><span class=\"p\">)</span>\n</code></pre></div>\n\n<p>TSP types <code>tsp.extra.obstacles.TSP_O</code> and <code>tsp.extra.color.TSP_Color</code> extend <code>TSP</code> and <code>N_TSP</code>\nrespectively.</p>\n"}, {"fullname": "tsp.core.tsp.distance", "modulename": "tsp.core.tsp", "qualname": "distance", "type": "function", "doc": "<p>Calculate the distance along a path of unspecified length.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>path (Iterable[NDArray]):</strong>  path as [[x1, y1, ...], ...]</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float: distance</p>\n</blockquote>\n", "parameters": ["path"], "funcdef": "def"}, {"fullname": "tsp.core.tsp.N_TSP", "modulename": "tsp.core.tsp", "qualname": "N_TSP", "type": "class", "doc": "<p>Container for a generic TSP instance.</p>\n"}, {"fullname": "tsp.core.tsp.N_TSP.__init__", "modulename": "tsp.core.tsp", "qualname": "N_TSP.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "tsp.core.tsp.N_TSP.from_cities", "modulename": "tsp.core.tsp", "qualname": "N_TSP.from_cities", "type": "function", "doc": "<p>Generate object from list/array of cities.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cities (NDArray):</strong>  cities as [[x1, y1, ...], ...]</li>\n</ul>\n", "parameters": ["cls", "cities"], "funcdef": "def"}, {"fullname": "tsp.core.tsp.N_TSP.dimensions", "modulename": "tsp.core.tsp", "qualname": "N_TSP.dimensions", "type": "variable", "doc": "<p>Number of dimensions the N_TSP problem is in.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>int: dimensions</p>\n</blockquote>\n"}, {"fullname": "tsp.core.tsp.N_TSP.add_city", "modulename": "tsp.core.tsp", "qualname": "N_TSP.add_city", "type": "function", "doc": "<p>Inefficiently adds a city to the problem.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>coords ([int]):</strong>  city coordinates as individual arguments</li>\n</ul>\n", "parameters": ["self", "coords"], "funcdef": "def"}, {"fullname": "tsp.core.tsp.N_TSP.edge", "modulename": "tsp.core.tsp", "qualname": "N_TSP.edge", "type": "function", "doc": "<p>Edge length between two cities.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>a (int):</strong>  index of first city</li>\n<li><strong>b (int):</strong>  index of second city</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float: edge length</p>\n</blockquote>\n", "parameters": ["self", "a", "b"], "funcdef": "def"}, {"fullname": "tsp.core.tsp.N_TSP.to_edges", "modulename": "tsp.core.tsp", "qualname": "N_TSP.to_edges", "type": "function", "doc": "<p>Produces iterable of edges (a, b, d) of distance d between vertices a and b.</p>\n\n<h6 id=\"yields\">Yields</h6>\n\n<blockquote>\n  <p>Iterator[int, int, float]: edges</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "tsp.core.tsp.N_TSP.to_edge_matrix", "modulename": "tsp.core.tsp", "qualname": "N_TSP.to_edge_matrix", "type": "function", "doc": "<p>Generate an edge matrix from the problem.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>NDArray: edge matrix</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "tsp.core.tsp.N_TSP.solve", "modulename": "tsp.core.tsp", "qualname": "N_TSP.solve", "type": "function", "doc": "<p>Generate a tour using a Solver.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>solver (Type):</strong>  should be a subclass of <code>tsp.core.solvers.Solver</code></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>NDArray: tour</p>\n</blockquote>\n", "parameters": ["self", "solver"], "funcdef": "def"}, {"fullname": "tsp.core.tsp.N_TSP.tour_segments", "modulename": "tsp.core.tsp", "qualname": "N_TSP.tour_segments", "type": "function", "doc": "<p>Convert a tour in index format into a tour in segment format.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tour (Iterable[int]):</strong>  tour as indices of cities</li>\n</ul>\n\n<h6 id=\"yields\">Yields</h6>\n\n<blockquote>\n  <p>Iterator[NDArray]: tour as coordinates of cities</p>\n</blockquote>\n", "parameters": ["self", "tour"], "funcdef": "def"}, {"fullname": "tsp.core.tsp.N_TSP.convert_tour_segments", "modulename": "tsp.core.tsp", "qualname": "N_TSP.convert_tour_segments", "type": "function", "doc": "<p>Convert a tour in segment format into a tour in index format.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tour_segments (Iterable[NDArray]):</strong>  tour as coordinates of cities</li>\n</ul>\n\n<h6 id=\"yields\">Yields</h6>\n\n<blockquote>\n  <p>Iterator[int]: tour as indices of cities</p>\n</blockquote>\n", "parameters": ["self", "tour_segments"], "funcdef": "def"}, {"fullname": "tsp.core.tsp.N_TSP.score_indices", "modulename": "tsp.core.tsp", "qualname": "N_TSP.score_indices", "type": "function", "doc": "<p>Calculate tour length (from index format).</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tour (Iterable[int]):</strong>  tour as indices of cities</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float: tour length</p>\n</blockquote>\n", "parameters": ["self", "tour"], "funcdef": "def"}, {"fullname": "tsp.core.tsp.N_TSP.score_tour_segments", "modulename": "tsp.core.tsp", "qualname": "N_TSP.score_tour_segments", "type": "function", "doc": "<p>Calculate tour length (from segment format).</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tour_segments (Iterable[NDArray]):</strong>  tour as coordinates of cities</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float: tour length</p>\n</blockquote>\n", "parameters": ["self", "tour_segments"], "funcdef": "def"}, {"fullname": "tsp.core.tsp.N_TSP.score", "modulename": "tsp.core.tsp", "qualname": "N_TSP.score", "type": "function", "doc": "<p>Calculate tour length (automatically detects index or segment format).</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tour (Iterable[Union[int, NDArray]]):</strong>  tour</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float: tour length</p>\n</blockquote>\n", "parameters": ["self", "tour"], "funcdef": "def"}, {"fullname": "tsp.core.tsp.TSP", "modulename": "tsp.core.tsp", "qualname": "TSP", "type": "class", "doc": "<p>Container for a 2D TSP instance. A wrapper which adds constraints to the N_TSP interface, primarily width and height.</p>\n"}, {"fullname": "tsp.core.tsp.TSP.__init__", "modulename": "tsp.core.tsp", "qualname": "TSP.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "w", "h"], "funcdef": "def"}, {"fullname": "tsp.core.tsp.TSP.generate_random", "modulename": "tsp.core.tsp", "qualname": "TSP.generate_random", "type": "function", "doc": "<p>Generate a new problem with uniformly-distributed random cities.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>n (int):</strong>  number of cities</li>\n<li><strong>w (int, optional):</strong>  Width of problem. Defaults to 500.</li>\n<li><strong>h (int, optional):</strong>  Height of problem. Defaults to 500.</li>\n<li><strong>r (int, optional):</strong>  Minimum distance between cities. Defaults to 10.</li>\n<li><strong>padding (int, optional):</strong>  Minimum distance a city can be from the edge. Defaults to 10.</li>\n</ul>\n", "parameters": ["cls", "n", "w", "h", "r", "padding"], "funcdef": "def"}, {"fullname": "tsp.core.tsp.TSP.from_cities", "modulename": "tsp.core.tsp", "qualname": "TSP.from_cities", "type": "function", "doc": "<p>Generate object from list/array of cities.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cities (NDArray):</strong>  cities as [[x1, y1], ...]</li>\n<li><strong>w (int, optional):</strong>  Width of problem. Defaults to 500.</li>\n<li><strong>h (int, optional):</strong>  Height of problem. Defaults to 500.</li>\n</ul>\n", "parameters": ["cls", "cities", "w", "h"], "funcdef": "def"}, {"fullname": "tsp.core.viz", "modulename": "tsp.core.viz", "qualname": "", "type": "module", "doc": "<p>Procedures for visualizing 2D and 3D TSPs and tours.</p>\n\n<p><code>visualize_tsp_pil</code> and <code>visualize_mst_pil</code> use the Python Imaging Library (PIL) backend, saving\nimage files with visualizations of 2D TSPs and MSTs (MSTs generated by <code>tsp.core.pyramid.mst</code>).</p>\n\n<p><code>visualize_3d</code> uses PIL and OpenCV to generate a movie visualizing 3D TSPs and tours using 3D\nmotion.</p>\n\n<p><code>visualize_tsp_plt</code> and <code>visualize_mst_plt</code> are similar to their associated <code>_pil</code> procedures, but\nuse the MatPlotLib backend. Can also be used to generate image files using the associated\nMatPlotLib directives, but are also great for inlining in Jupyter notebooks, etc.</p>\n"}, {"fullname": "tsp.core.viz.visualize_tsp_pil", "modulename": "tsp.core.viz", "qualname": "visualize_tsp_pil", "type": "function", "doc": "<p>Generate and save visualization of a TSP using PIL backend.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tsp (TSP):</strong>  the problem</li>\n<li><strong>tour (Iterable[Union[int, NDArray]]):</strong>  tour either as indices of vertices or as segments</li>\n<li><strong>path (str):</strong>  path to save</li>\n</ul>\n", "parameters": ["tsp", "tour", "path"], "funcdef": "def"}, {"fullname": "tsp.core.viz.visualize_mst_pil", "modulename": "tsp.core.viz", "qualname": "visualize_mst_pil", "type": "function", "doc": "<p>Generate and save visualization of an MST using PIL backend.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tsp (TSP):</strong>  the problem</li>\n<li><strong>edges (Iterable[NDArray]):</strong>  edges in MST as [[[x1, y1], [x2, y2]], ...]</li>\n<li><strong>path (str):</strong>  path to save</li>\n</ul>\n", "parameters": ["tsp", "edges", "path"], "funcdef": "def"}, {"fullname": "tsp.core.viz.visualize_3d", "modulename": "tsp.core.viz", "qualname": "visualize_3d", "type": "function", "doc": "<p>Generate and save visualization of 3D motion of a 3D TSP as an mp4.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tsp (N_TSP):</strong>  the problem</li>\n<li><strong>tour (Iterable[Union[int, NDArray]]):</strong>  tour either as indices of vertices or as segments</li>\n<li><strong>path (str):</strong>  path to save</li>\n<li><strong>step (int, optional):</strong>  Degrees to rotate per frame. Defaults to 1.</li>\n<li><strong>time (int, optional):</strong>  Duration of generated video. Defaults to 12.</li>\n</ul>\n", "parameters": ["tsp", "tour", "path", "step", "time"], "funcdef": "def"}, {"fullname": "tsp.core.viz.visualize_tsp_plt", "modulename": "tsp.core.viz", "qualname": "visualize_tsp_plt", "type": "function", "doc": "<p>Generate visualization of a TSP using MatPlotLib backend.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tsp (TSP):</strong>  the problem</li>\n<li><strong>tour (Iterable[Union[int, NDArray]]):</strong>  tour either as indices of vertices or as segments</li>\n<li><strong>ax (SubplotBase):</strong>  Matplotlib axes to plot on. Defaults to None.</li>\n</ul>\n", "parameters": ["tsp", "tour", "ax"], "funcdef": "def"}, {"fullname": "tsp.core.viz.visualize_mst_plt", "modulename": "tsp.core.viz", "qualname": "visualize_mst_plt", "type": "function", "doc": "<p>Generate visualization of an MST using MatPlotLib backend.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tsp (TSP):</strong>  the problem</li>\n<li><strong>edges (Iterable[NDArray]):</strong>  edges in MST as [[[x1, y1], [x2, y2]], ...]</li>\n<li><strong>ax (SubplotBase):</strong>  Matplotlib axes to plot on. Defaults to None.</li>\n</ul>\n", "parameters": ["tsp", "edges", "ax"], "funcdef": "def"}, {"fullname": "tsp.experiment", "modulename": "tsp.experiment", "qualname": "", "type": "module", "doc": "<p>This module implements tools for running experiments, including helper functions\nfor saving whole sets of problems and tours and calculating statistics, as well as a user interface\nfor collecting human participant tours of problem sets.</p>\n\n<p><code>tsp.experiment.batch</code> contains helper functions for saving and loading sets of problems and tours.</p>\n\n<p><code>tsp.experiment.batch_server</code> contains a user interface (UI) for collecting solutions to problem\nsets from human subjects. <code>tsp.experiment.run</code> contains some advanced tools for automating\nexperiments with multiple experimental conditions.</p>\n\n<p><code>tsp.experiment.batch_solver</code> contains helper functions for generating solutions to problem sets\nprogrammatically (e.g., with the Concorde solver), and computing statistics for problem sets.</p>\n\n<h3 id=\"setting-up-a-simple-experiment\">Setting Up a Simple Experiment</h3>\n\n<p>First, generate a set of problems (in this case, we will create a set of 10 20-city problems).</p>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">problems</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">):</span>\n    <span class=\"n\">problems</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">TSP</span><span class=\"o\">.</span><span class=\"n\">generate_random</span><span class=\"p\">(</span><span class=\"mi\">20</span><span class=\"p\">))</span>\n</code></pre></div>\n\n<p>Then, save the problem set in <code>test/problems</code>.</p>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">save_problem_batch</span><span class=\"p\">(</span><span class=\"n\">problems</span><span class=\"p\">,</span> <span class=\"s1\">&#39;test/problems&#39;</span><span class=\"p\">)</span>\n</code></pre></div>\n\n<p>Now, run the UI to collect solutions from the human (the UI can be accessed at\n<a href=\"http://localhost:8080\">localhost:8080</a>). Save them in <code>test/human</code>.</p>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">batch_server_run</span><span class=\"p\">(</span><span class=\"s1\">&#39;test/problems&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;test/human&#39;</span><span class=\"p\">,</span> <span class=\"n\">randomized</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</code></pre></div>\n\n<p>Generate Concorde solutions to the problem set, saving them in <code>test/concorde</code>.</p>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">solve_batch</span><span class=\"p\">(</span><span class=\"s1\">&#39;test/problems&#39;</span><span class=\"p\">,</span> <span class=\"n\">ConcordeSolver</span><span class=\"p\">,</span> <span class=\"s1\">&#39;test/concorde&#39;</span><span class=\"p\">)</span>\n</code></pre></div>\n\n<p>Finally, you can generate the errors when comparing the human tours to the optimal tours produced by\nConcorde.</p>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">errors</span><span class=\"p\">,</span> <span class=\"n\">mean</span><span class=\"p\">,</span> <span class=\"n\">ste</span> <span class=\"o\">=</span> <span class=\"n\">score_batch_2</span><span class=\"p\">(</span><span class=\"s1\">&#39;test/problems&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;test/human&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;test/concorde&#39;</span><span class=\"p\">)</span>\n</code></pre></div>\n\n<p><code>errors</code> will store an array of the errors for the 10 problems, <code>mean</code> the mean of the 10 errors,\nand <code>ste</code> the standard error of the mean.</p>\n"}, {"fullname": "tsp.experiment.batch", "modulename": "tsp.experiment.batch", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tsp.experiment.batch.save_problem_batch", "modulename": "tsp.experiment.batch", "qualname": "save_problem_batch", "type": "function", "doc": "<p>Serialize a batch of problems, following the numbering format <code>001.tsp</code>, etc.\nCan handle any N_TSP descendant from tsp.core or tsp.extra.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>objs (Iterable[Any]):</strong>  problems</li>\n<li><strong>path (str):</strong>  root to save in</li>\n<li><strong>starting_index (int, optional):</strong>  Starting index for numbering. Defaults to 1.</li>\n</ul>\n", "parameters": ["objs", "path", "starting_index"], "funcdef": "def"}, {"fullname": "tsp.experiment.batch.load_problem_batch", "modulename": "tsp.experiment.batch", "qualname": "load_problem_batch", "type": "function", "doc": "<p>Unserialize a batch of problems.\nCan handle any N_TSP descendant from tsp.core or tsp.extra.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>path (str):</strong>  root to load from</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Iterable[Any]: problems</p>\n</blockquote>\n", "parameters": ["path"], "funcdef": "def"}, {"fullname": "tsp.experiment.batch.save_list_item", "modulename": "tsp.experiment.batch", "qualname": "save_list_item", "type": "function", "doc": "<p>Generic save function wrapping tsp.core.save.save_list.\nSerializes tour/sequence to a file with format, e.g., <code>001.ext</code> if index is 1.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>obj (Iterable[Any]):</strong>  list</li>\n<li><strong>path (str):</strong>  root to save in</li>\n<li><strong>ext (str):</strong>  file extension to save as</li>\n<li><strong>index (int):</strong>  index</li>\n</ul>\n", "parameters": ["obj", "path", "ext", "index"], "funcdef": "def"}, {"fullname": "tsp.experiment.batch.save_list_batch", "modulename": "tsp.experiment.batch", "qualname": "save_list_batch", "type": "function", "doc": "<p>Generic save function for batch of tours/sequences.\nSerializes following the numbering format <code>001.ext</code>, etc.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>objs (Iterable[Iterable[Any]]):</strong>  lists</li>\n<li><strong>path (str):</strong>  root to save in</li>\n<li><strong>ext (str):</strong>  file extension to save as</li>\n<li><strong>starting_index (int, optional):</strong>  Starting index for numbering. Defaults to 1.</li>\n</ul>\n", "parameters": ["objs", "path", "ext", "starting_index"], "funcdef": "def"}, {"fullname": "tsp.experiment.batch.load_list_batch", "modulename": "tsp.experiment.batch", "qualname": "load_list_batch", "type": "function", "doc": "<p>Generic load function for batch of tours/sequences.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>path (str):</strong>  root to load from</li>\n<li><strong>ext (str):</strong>  file extension to load</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>List[List[Any]]: lists</p>\n</blockquote>\n", "parameters": ["path", "ext"], "funcdef": "def"}, {"fullname": "tsp.experiment.batch_server", "modulename": "tsp.experiment.batch_server", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tsp.experiment.batch_server.batch_server_run", "modulename": "tsp.experiment.batch_server", "qualname": "batch_server_run", "type": "function", "doc": "<p>Run a subject on a batch of problems.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>problems_path (str):</strong>  path to batch of problems</li>\n<li><strong>output_dir (str):</strong>  path to save solutions</li>\n<li><strong>randomized (bool):</strong>  whether or not to randomize the order in which problems are presented</li>\n<li><strong>ui_root (str, optional):</strong>  Path to UI (should only need to be used if creating a standalone executable). Defaults to None.</li>\n</ul>\n", "parameters": ["problems_path", "output_dir", "randomized", "ui_root"], "funcdef": "def"}, {"fullname": "tsp.experiment.batch_solver", "modulename": "tsp.experiment.batch_solver", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tsp.experiment.batch_solver.solve_batch", "modulename": "tsp.experiment.batch_solver", "qualname": "solve_batch", "type": "function", "doc": "<p>Use a solver to generate tours for a batch of problems.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>src (str):</strong>  path of root where problems are saved</li>\n<li><strong>solver (Solver):</strong>  an instance of a Solver (tsp.core.solvers.Solver)</li>\n<li><strong>dest (str, optional):</strong>  Path of root to save tours. Defaults to None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>List[List[int]]: tours</p>\n</blockquote>\n", "parameters": ["src", "solver", "dest"], "funcdef": "def"}, {"fullname": "tsp.experiment.batch_solver.score_tours_absolute", "modulename": "tsp.experiment.batch_solver", "qualname": "score_tours_absolute", "type": "function", "doc": "<p>Calculate tour lengths for a batch of tours.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>problems (List[N_TSP]):</strong>  list of TSPs</li>\n<li><strong>tours (List[Union[int, NDArray]]):</strong>  list of tours (in either index or segment format)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>NDArray: tour lengths</p>\n</blockquote>\n", "parameters": ["problems", "tours"], "funcdef": "def"}, {"fullname": "tsp.experiment.batch_solver.score_batch", "modulename": "tsp.experiment.batch_solver", "qualname": "score_batch", "type": "function", "doc": "<p>Calculate tour lengths for a batch of tours, for use on serialized problems and tours.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>problems_path (str):</strong>  path of root where problems are saved</li>\n<li><strong>tours_path (str):</strong>  path of root where tours are saved</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>NDArray: tour lengths</p>\n</blockquote>\n", "parameters": ["problems_path", "tours_path"], "funcdef": "def"}, {"fullname": "tsp.experiment.batch_solver.score_tours_relative", "modulename": "tsp.experiment.batch_solver", "qualname": "score_tours_relative", "type": "function", "doc": "<p>Calculate tour errors relative to reference tours (for example, the optimal tours solved by Concorde).</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>problems (List[N_TSP]):</strong>  list of TSPs</li>\n<li><strong>tours (List[Union[int, NDArray]]):</strong>  list of tours (in either index or segment format)</li>\n<li><strong>base_tours (List[Union[int, NDArray]]):</strong>  list of reference tours (in either index or segment format)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Tuple[NDArray, float, float]: (proportional errors, mean error, standard error of mean)</p>\n</blockquote>\n", "parameters": ["problems", "tours", "base_tours"], "funcdef": "def"}, {"fullname": "tsp.experiment.batch_solver.score_batch_2", "modulename": "tsp.experiment.batch_solver", "qualname": "score_batch_2", "type": "function", "doc": "<p>Calculate tour errors relative to reference tours, for use on serialized problems and tours.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>problems_path (str):</strong>  path of root where problems are saved</li>\n<li><strong>tours_path (str):</strong>  path of root where tours are saved</li>\n<li><strong>base_tours_path (str):</strong>  path of root where reference tours are saved</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Tuple[NDArray, float, float]: (proportional errors, mean error, standard error of mean)</p>\n</blockquote>\n", "parameters": ["problems_path", "tours_path", "base_tours_path"], "funcdef": "def"}, {"fullname": "tsp.experiment.batch_solver.score_batch_3", "modulename": "tsp.experiment.batch_solver", "qualname": "score_batch_3", "type": "function", "doc": "<p>Calculate tour errors relative to reference tours, for use on serialized problems and tours.\nExpects serialized tours (in tours_path) to be in segment format (i.e., generated by a human subject),\nand converts them to index format.\nUnless you're doing specialized work with the TSP_O library, you probably don't need this.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>problems_path (str):</strong>  path of root where problems are saved</li>\n<li><strong>tours_path (str):</strong>  path of root where tours are saved (in segment format)</li>\n<li><strong>base_tours_path (str):</strong>  path of root where reference tours are saved</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Tuple[NDArray, float, float]: (proportional errors, mean error, standard error of mean)</p>\n</blockquote>\n", "parameters": ["problems_path", "tours_path", "base_tours_path"], "funcdef": "def"}, {"fullname": "tsp.experiment.run", "modulename": "tsp.experiment.run", "qualname": "", "type": "module", "doc": "<p>Problem set file format:</p>\n\n<ul>\n<li>List of paths to problem sets (without /problems)</li>\n<li>Asterisk (*) in front of paths that should be kept in the position that it is in</li>\n<li>Ampersand (&amp;) in front of paths that should not have their problems presented in random order (after the * if they coincide)</li>\n</ul>\n\n<p>Example:</p>\n\n<p>*./simulations4/data/set_test\n./simulations4/data/set_16_128\n./simulations4/data/set_16_192\n./simulations4/data/set_16_256\n./simulations4/data/set_32_128\n./simulations4/data/set_32_192\n./simulations4/data/set_32_256\n./simulations4/data/set_48_128\n./simulations4/data/set_48_192\n./simulations4/data/set_48_256</p>\n"}, {"fullname": "tsp.experiment.run.run", "modulename": "tsp.experiment.run", "qualname": "run", "type": "function", "doc": "<p>Run a subject on a set of experimental conditions.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>participant (str):</strong>  participant identifier</li>\n<li><strong>set_list_path (str):</strong>  path to set list file (see module documentation for expected format)</li>\n<li><strong>save_file_path (str):</strong>  path to save the ordering of experimental conditions (mainly useful if randomized)</li>\n<li><strong>ui_root (str, optional):</strong>  Path to UI (should only need to be used if creating a standalone executable). Defaults to None.</li>\n</ul>\n", "parameters": ["participant", "set_list_path", "save_file_path", "ui_root"], "funcdef": "def"}, {"fullname": "tsp.extra", "modulename": "tsp.extra", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tsp.extra.color", "modulename": "tsp.extra.color", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tsp.extra.color.TSP_Color", "modulename": "tsp.extra.color", "qualname": "TSP_Color", "type": "class", "doc": "<p>Container for a TSP-with-colors instance.</p>\n"}, {"fullname": "tsp.extra.color.TSP_Color.__init__", "modulename": "tsp.extra.color", "qualname": "TSP_Color.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "w", "h", "penalty"], "funcdef": "def"}, {"fullname": "tsp.extra.color.TSP_Color.generate_random", "modulename": "tsp.extra.color", "qualname": "TSP_Color.generate_random", "type": "function", "doc": "<p>Generate a new problem with uniformly-distributed random cities of different colors.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>n_colors (Iterable[int]):</strong>  number of cities of each color, for example [25, 25] would be a\n50-city problem with two colors evenly distributed</li>\n<li><strong>w (int, optional):</strong>  Width of problem. Defaults to 500.</li>\n<li><strong>h (int, optional):</strong>  Height of problem. Defaults to 500.</li>\n<li><strong>penalty (float, optional):</strong>  Distance multiplier when traveling between colors. Defaults to 2.0.</li>\n</ul>\n", "parameters": ["cls", "n_colors", "w", "h", "penalty"], "funcdef": "def"}, {"fullname": "tsp.extra.color.TSP_Color.from_cities", "modulename": "tsp.extra.color", "qualname": "TSP_Color.from_cities", "type": "function", "doc": "<p>Generate object from list/array of (colored) cities.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cities (Iterable[Tuple[Tuple[int, int], int]]):</strong>  colored cities as [((x1, y1), c1), ...]</li>\n<li><strong>w (int, optional):</strong>  Width of problem. Defaults to 500.</li>\n<li><strong>h (int, optional):</strong>  Height of problem. Defaults to 500.</li>\n<li><strong>penalty (float, optional):</strong>  Distance multiplier when traveling between colors. Defaults to 2.0.</li>\n</ul>\n", "parameters": ["cls", "cities", "w", "h", "penalty"], "funcdef": "def"}, {"fullname": "tsp.extra.color.TSP_Color.add_city", "modulename": "tsp.extra.color", "qualname": "TSP_Color.add_city", "type": "function", "doc": "<p>Inefficiently adds a (colored) city to the problem.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>x (int):</strong>  city x</li>\n<li><strong>y (int):</strong>  city y</li>\n<li><strong>color (int):</strong>  city color</li>\n</ul>\n", "parameters": ["self", "x", "y", "color"], "funcdef": "def"}, {"fullname": "tsp.extra.color.TSP_Color.edge", "modulename": "tsp.extra.color", "qualname": "TSP_Color.edge", "type": "function", "doc": "<p>Edge length between two cities, taking into account penalties for switching colors.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>a (int):</strong>  index of first city</li>\n<li><strong>b (int):</strong>  index of second city</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float: edge length</p>\n</blockquote>\n", "parameters": ["self", "a", "b"], "funcdef": "def"}, {"fullname": "tsp.extra.mds", "modulename": "tsp.extra.mds", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tsp.extra.mds.stress", "modulename": "tsp.extra.mds", "qualname": "stress", "type": "function", "doc": "<p>Compute Kruskal's stress-1 between the distance matrices of two TSPs.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tsp_a (N_TSP):</strong>  first TSP</li>\n<li><strong>tsp_b (N_TSP):</strong>  second TSP</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float: stress</p>\n</blockquote>\n", "parameters": ["tsp_a", "tsp_b"], "funcdef": "def"}, {"fullname": "tsp.extra.mds.recover_local_scaled", "modulename": "tsp.extra.mds", "qualname": "recover_local_scaled", "type": "function", "doc": "<p>Use Procrustes scaling to make the MDS reconstruction fit the original problem as best as possible.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>original (N_TSP):</strong>  original problem</li>\n<li><strong>reconstructed (NDArray):</strong>  MDS reconstruction</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>TSP: reconstructed problem of guaranteed same height and width</p>\n</blockquote>\n", "parameters": ["original", "reconstructed"], "funcdef": "def"}, {"fullname": "tsp.extra.mds.do_mds", "modulename": "tsp.extra.mds", "qualname": "do_mds", "type": "function", "doc": "<p>Generate an MDS reconstruction of any TSP problem. If both problems are of dimension 2,\nreconstruction will be scaled to match original as best as possible.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tsp (N_TSP):</strong>  original problem</li>\n<li><strong>dimensions (int, optional):</strong>  Dimension of MDS reconstruction. Defaults to 2.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Tuple[N_TSP, N_TSP, float]: (original problem, reconstructed problem, stress-1)</p>\n</blockquote>\n", "parameters": ["tsp", "dimensions"], "funcdef": "def"}, {"fullname": "tsp.extra.obstacles", "modulename": "tsp.extra.obstacles", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tsp.extra.obstacles.TSP_O", "modulename": "tsp.extra.obstacles", "qualname": "TSP_O", "type": "class", "doc": "<p>Container for a TSP-with-obstacles instance.</p>\n"}, {"fullname": "tsp.extra.obstacles.TSP_O.__init__", "modulename": "tsp.extra.obstacles", "qualname": "TSP_O.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "w", "h"], "funcdef": "def"}, {"fullname": "tsp.extra.obstacles.TSP_O.generate_random_safe", "modulename": "tsp.extra.obstacles", "qualname": "TSP_O.generate_random_safe", "type": "function", "doc": "<p>Generate a random problem in which cities are min_dist from the obstacles.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>n (int):</strong>  number of cities</li>\n<li><strong>w (int, optional):</strong>  Width of problem. Defaults to 500.</li>\n<li><strong>h (int, optional):</strong>  Height of problem. Defaults to 500.</li>\n<li><strong>r (int, optional):</strong>  Minimum distance between cities. Defaults to 10.</li>\n<li><strong>padding (int, optional):</strong>  Minimum distance a city can be from the edge. Defaults to 10.</li>\n<li><strong>n_obs (int, optional):</strong>  Number of obstacles. Defaults to 10.</li>\n<li><strong>edge_length (int, optional):</strong>  Length of obstacles. Defaults to 20.</li>\n<li><strong>min_dist (int, optional):</strong>  Minimum distance a city can be from an obstacle. Defaults to 10.</li>\n</ul>\n", "parameters": ["cls", "n", "w", "h", "r", "padding", "n_obs", "edge_length", "min_dist"], "funcdef": "def"}, {"fullname": "tsp.extra.obstacles.TSP_O.add_obstacle", "modulename": "tsp.extra.obstacles", "qualname": "TSP_O.add_obstacle", "type": "function", "doc": "<p>Inefficiently add obstacles to the problem.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>vertices ([int, int]):</strong>  obstacle vertices as [x1, y1], ...</li>\n</ul>\n", "parameters": ["self", "vertices"], "funcdef": "def"}, {"fullname": "tsp.extra.obstacles.TSP_O.to_visgraph", "modulename": "tsp.extra.obstacles", "qualname": "TSP_O.to_visgraph", "type": "function", "doc": "<p>Generate and return a visibility graph for the problem.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>rebuild (bool, optional):</strong>  Whether or not to rebuild from scratch. Defaults to False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>DefaultDict: visibility graph</p>\n</blockquote>\n", "parameters": ["self", "rebuild"], "funcdef": "def"}, {"fullname": "tsp.extra.obstacles.TSP_O.edge", "modulename": "tsp.extra.obstacles", "qualname": "TSP_O.edge", "type": "function", "doc": "<p>Calculate shortest path between two cities.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>a (int):</strong>  index of first city</li>\n<li><strong>b (int):</strong>  index of second city</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float: edge length</p>\n</blockquote>\n", "parameters": ["self", "a", "b"], "funcdef": "def"}, {"fullname": "tsp.extra.obstacles.TSP_O.to_edges", "modulename": "tsp.extra.obstacles", "qualname": "TSP_O.to_edges", "type": "function", "doc": "<p>Produces iterable of edges (a, b, d) of distance d between vertices a and b.</p>\n\n<h6 id=\"yields\">Yields</h6>\n\n<blockquote>\n  <p>Iterator[int, int, float]: edges</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "tsp.extra.obstacles.TSP_O.to_edge_matrix", "modulename": "tsp.extra.obstacles", "qualname": "TSP_O.to_edge_matrix", "type": "function", "doc": "<p>Generate an edge matrix from the problem.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>NDArray: edge matrix</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "tsp.extra.obstacles.TSP_O.tour_segments", "modulename": "tsp.extra.obstacles", "qualname": "TSP_O.tour_segments", "type": "function", "doc": "<p>Produces iterator of vertices (x, y) that, when connected, make up the tour in obstacle space.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tour (Iterable[int]):</strong>  tour as indices of cities</li>\n</ul>\n\n<h6 id=\"yields\">Yields</h6>\n\n<blockquote>\n  <p>Iterator[NDArray]: tour as coordinates of line segments</p>\n</blockquote>\n", "parameters": ["self", "tour"], "funcdef": "def"}, {"fullname": "tsp.extra.obstacles.TSP_O.add_random_obstacle", "modulename": "tsp.extra.obstacles", "qualname": "TSP_O.add_random_obstacle", "type": "function", "doc": "<p>Add an obstacle with random positioning and rotation.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>edge_length (int, optional):</strong>  Obstacle length. Defaults to 20.</li>\n</ul>\n", "parameters": ["self", "edge_length"], "funcdef": "def"}, {"fullname": "tsp.extra.obstacles.TSP_O.add_random_obstacles", "modulename": "tsp.extra.obstacles", "qualname": "TSP_O.add_random_obstacles", "type": "function", "doc": "<p>Add multiple random obstacles.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>n (int):</strong>  number of obstacles</li>\n<li><strong>edge_length (int, optional):</strong>  Obstacle length. Defaults to 20.</li>\n</ul>\n", "parameters": ["self", "n", "edge_length"], "funcdef": "def"}, {"fullname": "tsp.extra.obstacles.TSP_O.add_random_obstacles_from_template", "modulename": "tsp.extra.obstacles", "qualname": "TSP_O.add_random_obstacles_from_template", "type": "function", "doc": "<p>Add obstacles using a template.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>template (Template):</strong>  template</li>\n<li><strong>n (int, optional):</strong>  Number of obstacles. Defaults to 1.</li>\n<li><strong>start_offsets (tuple, optional):</strong>  Bounds for template (see template documentation). Defaults to (0, 0).</li>\n</ul>\n", "parameters": ["self", "template", "n", "start_offsets"], "funcdef": "def"}, {"fullname": "tsp.extra.save", "modulename": "tsp.extra.save", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tsp.extra.save.save_obstacles", "modulename": "tsp.extra.save", "qualname": "save_obstacles", "type": "function", "doc": "<p>Serialize a TSP_O object.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>obj (TSP_O):</strong>  object</li>\n<li><strong>path (str):</strong>  path to save</li>\n</ul>\n", "parameters": ["obj", "path"], "funcdef": "def"}, {"fullname": "tsp.extra.save.load_obstacles", "modulename": "tsp.extra.save", "qualname": "load_obstacles", "type": "function", "doc": "<p>Unserialize a TSP_O object.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>path (str):</strong>  path to load</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>TSP_O: object</p>\n</blockquote>\n", "parameters": ["path"], "funcdef": "def"}, {"fullname": "tsp.extra.save.save_color", "modulename": "tsp.extra.save", "qualname": "save_color", "type": "function", "doc": "<p>Serialize a TSP_Color object.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>obj (TSP_Color):</strong>  object</li>\n<li><strong>path (str):</strong>  path to save</li>\n</ul>\n", "parameters": ["obj", "path"], "funcdef": "def"}, {"fullname": "tsp.extra.save.load_color", "modulename": "tsp.extra.save", "qualname": "load_color", "type": "function", "doc": "<p>Unserialize a TSP_Color object.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>path (str):</strong>  path to load</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>TSP_Color: object</p>\n</blockquote>\n", "parameters": ["path"], "funcdef": "def"}, {"fullname": "tsp.extra.save.save_problem", "modulename": "tsp.extra.save", "qualname": "save_problem", "type": "function", "doc": "<p>Serialize an object (should be descended from N_TSP, supports TSP_O and TSP_Color).</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>obj (Any):</strong>  object</li>\n<li><strong>path (str):</strong>  path to save</li>\n</ul>\n", "parameters": ["obj", "path"], "funcdef": "def"}, {"fullname": "tsp.extra.save.load_problem", "modulename": "tsp.extra.save", "qualname": "load_problem", "type": "function", "doc": "<p>Unserialize an object (TSP_O, TSP_Color, TSP, or N_TSP).</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>path (str):</strong>  path to load</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>LoadError:</strong>  serialized object not supported</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Any: object</p>\n</blockquote>\n", "parameters": ["path"], "funcdef": "def"}, {"fullname": "tsp.extra.templates", "modulename": "tsp.extra.templates", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tsp.extra.templates.Point", "modulename": "tsp.extra.templates", "qualname": "Point", "type": "class", "doc": "<p>Container for a 2D point.</p>\n"}, {"fullname": "tsp.extra.templates.Point.__init__", "modulename": "tsp.extra.templates", "qualname": "Point.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "x", "y"], "funcdef": "def"}, {"fullname": "tsp.extra.templates.Point.random", "modulename": "tsp.extra.templates", "qualname": "Point.random", "type": "function", "doc": "<p>Generates a random point.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>x_bounds (Tuple[float, float]):</strong>  min and max x</li>\n<li><strong>y_bounds (Tuple[float, float]):</strong>  min and max y</li>\n</ul>\n", "parameters": ["cls", "x_bounds", "y_bounds"], "funcdef": "def"}, {"fullname": "tsp.extra.templates.Point.coord", "modulename": "tsp.extra.templates", "qualname": "Point.coord", "type": "variable", "doc": "<p>Cartestian coordinates of the point.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Tuple[float, float]: (x, y)</p>\n</blockquote>\n"}, {"fullname": "tsp.extra.templates.Direction", "modulename": "tsp.extra.templates", "qualname": "Direction", "type": "class", "doc": "<p>Container for a direction (radians).</p>\n"}, {"fullname": "tsp.extra.templates.Direction.__init__", "modulename": "tsp.extra.templates", "qualname": "Direction.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "a"], "funcdef": "def"}, {"fullname": "tsp.extra.templates.Direction.random", "modulename": "tsp.extra.templates", "qualname": "Direction.random", "type": "function", "doc": "<p>Generates a direction of random angle.</p>\n", "parameters": ["cls"], "funcdef": "def"}, {"fullname": "tsp.extra.templates.Direction.add", "modulename": "tsp.extra.templates", "qualname": "Direction.add", "type": "function", "doc": "<p>Find the point m distance from p in direction.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>p (Point):</strong>  origin</li>\n<li><strong>m (float):</strong>  magnitude</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Point: tip</p>\n</blockquote>\n", "parameters": ["self", "p", "m"], "funcdef": "def"}, {"fullname": "tsp.extra.templates.Component", "modulename": "tsp.extra.templates", "qualname": "Component", "type": "class", "doc": "<p>Interface for a template component.</p>\n"}, {"fullname": "tsp.extra.templates.Component.__init__", "modulename": "tsp.extra.templates", "qualname": "Component.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "tsp.extra.templates.Line", "modulename": "tsp.extra.templates", "qualname": "Line", "type": "class", "doc": "<p>Add line obstacle.</p>\n"}, {"fullname": "tsp.extra.templates.Line.__init__", "modulename": "tsp.extra.templates", "qualname": "Line.__init__", "type": "function", "doc": "<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>m (float):</strong>  length</li>\n</ul>\n", "parameters": ["self", "m"], "funcdef": "def"}, {"fullname": "tsp.extra.templates.Turn", "modulename": "tsp.extra.templates", "qualname": "Turn", "type": "class", "doc": "<p>Change angle.</p>\n"}, {"fullname": "tsp.extra.templates.Turn.__init__", "modulename": "tsp.extra.templates", "qualname": "Turn.__init__", "type": "function", "doc": "<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>a (float):</strong>  amount to rotate</li>\n</ul>\n", "parameters": ["self", "a"], "funcdef": "def"}, {"fullname": "tsp.extra.templates.Gap", "modulename": "tsp.extra.templates", "qualname": "Gap", "type": "class", "doc": "<p>Skip some amount of space.</p>\n"}, {"fullname": "tsp.extra.templates.Gap.__init__", "modulename": "tsp.extra.templates", "qualname": "Gap.__init__", "type": "function", "doc": "<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>m (float):</strong>  distance</li>\n</ul>\n", "parameters": ["self", "m"], "funcdef": "def"}, {"fullname": "tsp.extra.templates.Template", "modulename": "tsp.extra.templates", "qualname": "Template", "type": "class", "doc": "<p>Container for a template (composed of a list of components).</p>\n"}, {"fullname": "tsp.extra.templates.Template.__init__", "modulename": "tsp.extra.templates", "qualname": "Template.__init__", "type": "function", "doc": "<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>components (List[Component]):</strong>  components to be sequentially inserted</li>\n<li><strong>o (Point, optional):</strong>  Origin point, if None then will be randomly generated. Defaults to None.</li>\n<li><strong>d (Direction, optional):</strong>  Starting direction, if None then will be randomly generated. Defaults to None.</li>\n</ul>\n", "parameters": ["self", "components", "o", "d"], "funcdef": "def"}, {"fullname": "tsp.extra.visgraph", "modulename": "tsp.extra.visgraph", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tsp.extra.visgraph.calculate_visgraph", "modulename": "tsp.extra.visgraph", "qualname": "calculate_visgraph", "type": "function", "doc": "<p>Calculate a visibility graph. Obstacle endpoints are included in the graph.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>vertices (List[Point]):</strong>  list of vertices</li>\n<li><strong>obstacles (List[Line]):</strong>  list of obstacles</li>\n<li><strong>bound (Tuple[int, int], optional):</strong>  Maximum x and y (excludes vertices and obstacle endpoints outside of this). Defaults to None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Graph: table of all vertices visible (value) from any given vertex (key)</p>\n</blockquote>\n", "parameters": ["vertices", "obstacles", "bound"], "funcdef": "def"}, {"fullname": "tsp.extra.visgraph.shortest_path", "modulename": "tsp.extra.visgraph", "qualname": "shortest_path", "type": "function", "doc": "<p>Shortest path (calculated with Dijkstra's) between points a and b in the visibility graph,\ntaking into account navigation around obstacles.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>a (Point):</strong>  starting point</li>\n<li><strong>b (Point):</strong>  end point</li>\n<li><strong>graph (Graph):</strong>  visibility graph (must contain a and b)</li>\n<li><strong>exclude (List[Point], optional):</strong>  Points in the graph which cannot be on the path. Defaults to None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>List[Point]: [description]</p>\n</blockquote>\n", "parameters": ["a", "b", "graph", "exclude"], "funcdef": "def"}, {"fullname": "tsp.extra.viz", "modulename": "tsp.extra.viz", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tsp.extra.viz.visualize_obstacles_pil", "modulename": "tsp.extra.viz", "qualname": "visualize_obstacles_pil", "type": "function", "doc": "<p>Generate and save visualization of a TSP_O using PIL backend.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tsp (TSP_O):</strong>  the problem</li>\n<li><strong>tour (Iterable[Union[int, NDArray]]):</strong>  tour either as indices of vertices or as segments</li>\n<li><strong>path (str):</strong>  path to save</li>\n</ul>\n", "parameters": ["tsp", "tour", "path"], "funcdef": "def"}, {"fullname": "tsp.extra.viz.visualize_obstacles_plt", "modulename": "tsp.extra.viz", "qualname": "visualize_obstacles_plt", "type": "function", "doc": "<p>Generate visualization of a TSP_O using MatPlotLib backend.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tsp (TSP_O):</strong>  the problem</li>\n<li><strong>tour (Iterable[Union[int, NDArray]]):</strong>  tour either as indices of vertices or as segments</li>\n<li><strong>ax (SubplotBase):</strong>  Matplotlib axes to plot on. Defaults to None.</li>\n</ul>\n", "parameters": ["tsp", "tour", "ax"], "funcdef": "def"}, {"fullname": "tsp.extra.viz.visualize_color_pil", "modulename": "tsp.extra.viz", "qualname": "visualize_color_pil", "type": "function", "doc": "<p>Generate and save visualization of a TSP_Color using PIL backend.\nDue to the fact that the TSP_Color code is underdeveloped, this is not as feature rich.\nOnly supports two colors, and tours as indices of vertices.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tsp (TSP_Color):</strong>  the problem</li>\n<li><strong>tour (Iterable[int]):</strong>  tour either as indices of vertices</li>\n<li><strong>path (str):</strong>  path to save</li>\n</ul>\n", "parameters": ["tsp", "tour", "path"], "funcdef": "def"}]